/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _scripts_game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scripts/game */ \"./src/scripts/game.js\");\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const canvasEl = document.getElementById(\"canvas\");\n  canvasEl.height = 450;\n  canvasEl.width = 700;\n  const ctx = canvasEl.getContext(\"2d\"); // ctx.fillStyle = \"grey\";\n  // ctx.fillRect(0, 0, 700, 450);\n\n  const game = new _scripts_game__WEBPACK_IMPORTED_MODULE_0__[\"default\"](ctx);\n}); // document.addEventListener(\"DOMContentLoaded\", () => {\n//     const canvasEl = document.getElementById(\"canvas\");\n//     canvasEl.height = 450;\n//     canvasEl.width = 700;\n//     const ctx = canvasEl.getContext(\"2d\");\n//     ctx.fillStyle = \"grey\";\n//     ctx.fillRect(0, 0, 700, 450);\n// navigator.mediaDevices.getUserMedia({\n//     video: {width: 700, height: 450},\n//     audio: false,\n// }).then((stream) => {\n//     video.srcObject = stream;\n// });\n// ctx.drawImage(video, 0, 0, 1000, 600);\n// video = document.getElementById(\"video\");\n// this.ctx.drawImage(video, 0, 0, 1000, 600);\n// const model = faceLandmarksDetection.SupportedModels.MediaPipeFaceMesh;\n// const detectorConfig = {\n// runtime: 'mediapipe', // or 'tfjs'\n// solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh',\n// }\n// const detector = await faceLandmarksDetection.createDetector(model, detectorConfig);\n// const faces = await detector.estimateFaces(image);\n// const game = new Game(ctx);\n// })\n// document.addEventListener(\"DOMContentLoaded\", () => {\n//     // let video = document.getElementById(\"video\");\n//     let video;\n//     let model;\n//     let canvas = document.getElementById(\"canvas\");\n//     let context = canvas.getContext(\"2d\");\n//     let mouthOpen = false;\n//     let eyesClosed = false;\n//     let face;\n//     let firstFace = true;\n//     const setUpCamera = () => {\n//         navigator.mediaDevices.getUserMedia({\n//             video: {width: 1000, height: 600},\n//             audio: false,\n//         }).then((stream) => {\n//             video.srcObject = stream;\n//         });\n//         context.drawImage(video, 0, 0, 1000, 600);\n//         video = document.getElementById(\"video\");\n//         loadFaceModel();\n//     }\n//     const loadFaceModel = async () => {\n//         model = await faceLandmarksDetection.load(\n//             faceLandmarksDetection.SupportedPackages.mediapipeFacemesh\n//         );\n//     }\n//     // const setUpCamera = () => {\n//     //     navigator.mediaDevices.getUserMedia({\n//     //         video: {width: 1000, height: 600},\n//     //         audio: false,\n//     //     }).then((stream) => {\n//     //         video.srcObject = stream;\n//     //     });\n//     // };\n//     const detectFaces = async () => {\n//         const facePrediction = await model.estimateFaces(video, false);\n//         if (facePrediction.length === 0) {\n//             return console.log(\"Error: no face detected\");\n//         }\n//         if (facePrediction.length > 1) {\n//             return console.log(\"Error: This app will only handle 1 person at a time\");\n//         }\n//         console.log(facePrediction);\n//         context.drawImage(video, 0, 0, 1000, 600);\n//         facePrediction.forEach((pred) => {\n//             context.beginPath();\n//             context.lineWidth = \"4\";\n//             context.strokeStyle = \"blue\";\n//             if (pred.bottomRight[0] - pred.topLeft[0] - 40 < 125 || pred.bottomRight[1] - pred.topLeft[1] + 110 < 200) {\n//                 return console.log(\"Error: Bring your face closer and keep it straight\");\n//             }\n//             if (pred.bottomRight[0] - pred.topLeft[0] - 40 > 225 || pred.bottomRight[1] - pred.topLeft[1] + 110 > 300) {\n//                 return console.log(\"Error: Back up a bit and keep your head straight\");\n//             }\n//             context.rect (\n//                 pred.topLeft[0] + 20,\n//                 pred.topLeft[1] - 100,\n//                 pred.bottomRight[0] - pred.topLeft[0] - 40,\n//                 pred.bottomRight[1] - pred.topLeft[1] + 110\n//             );\n//             context.stroke();\n//             context.fillStyle = \"red\";\n//             pred.landmarks.forEach((landmark) => {\n//                 context.fillRect(landmark[0], landmark[1], 5, 5);\n//             });\n//         });\n//     }\n//     const drawFace = async () => {\n//         // const facePrediction = await model.estimateFaces(video, false);\n//         debugger\n//         // if (video.loadedmetadata && model !== undefined) {\n//             detectFace();\n//         // }\n//         debugger\n//         if (face !== undefined) {\n//             context.drawImage(video, 0, 0, 1000, 600);\n//             if (firstFace) {\n//                 console.log(face);\n//                 firstFace = false;\n//             }\n//             fill(255);\n//             noStroke();\n//             for (let pt of face.scaledMesh) {\n//                 pt = scalePoint(pt);\n//                 circle(pt.x, pt.y, 3);\n//             }\n//             fill(0,150,255, 100);\n//             noStroke();\n//             beginShape();\n//             for (pt of face.annotations.silhouette) {\n//                 pt = scalePoint(pt);\n//                 vertex(pt.x, pt.y);\n//             }\n//             endShape(CLOSE);\n//         }\n//     }\n//     const scalePoint = (pt) => {\n//         let x = map(pt[0], 0,video.width, 0,width);\n//         let y = map(pt[1], 0,video.height, 0,height);\n//         return createVector(x, y);\n//     }\n//     const detectFace = async () => {\n//         debugger\n//         const facePredictions = await model.estimateFaces({\n//             input: document.querySelector('video')\n//         });\n//         console.log(facePredictions);\n//         debugger\n//         if (facePredictions.length === 0) {\n//             face = undefined;\n//             return console.log(\"Error: no face detected\");\n//         } else if (facePredictions.length > 1) {\n//             face = undefined;\n//             return console.log(\"Error: This app will only handle 1 person at a time\");\n//         } else {\n//             face = facePredictions[0];\n//         }\n//         debugger\n//     }\n//     setUpCamera();\n//     video.addEventListener(\"loadeddata\", async () => {\n//         model = await faceLandmarksDetection.load(\n//             faceLandmarksDetection.SupportedPackages.mediapipeFacemesh\n//         );\n//         // detectFace();\n//         drawFace();\n//         // setInterval(detectFace, 50);\n//     })\n// })//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUVBQyxRQUFRLENBQUNDLGdCQUFULENBQTBCLGtCQUExQixFQUE4QyxNQUFNO0VBQ2hELE1BQU1DLFFBQVEsR0FBR0YsUUFBUSxDQUFDRyxjQUFULENBQXdCLFFBQXhCLENBQWpCO0VBQ0FELFFBQVEsQ0FBQ0UsTUFBVCxHQUFrQixHQUFsQjtFQUNBRixRQUFRLENBQUNHLEtBQVQsR0FBaUIsR0FBakI7RUFDQSxNQUFNQyxHQUFHLEdBQUdKLFFBQVEsQ0FBQ0ssVUFBVCxDQUFvQixJQUFwQixDQUFaLENBSmdELENBS2hEO0VBQ0E7O0VBRUEsTUFBTUMsSUFBSSxHQUFHLElBQUlULHFEQUFKLENBQVNPLEdBQVQsQ0FBYjtBQUNILENBVEQsR0FXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDSjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0ZBQ0VNQU4tUmV2YW1wZWQvLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgR2FtZSBmcm9tIFwiLi9zY3JpcHRzL2dhbWVcIlxyXG5cclxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT4ge1xyXG4gICAgY29uc3QgY2FudmFzRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNhbnZhc1wiKTtcclxuICAgIGNhbnZhc0VsLmhlaWdodCA9IDQ1MDtcclxuICAgIGNhbnZhc0VsLndpZHRoID0gNzAwO1xyXG4gICAgY29uc3QgY3R4ID0gY2FudmFzRWwuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgLy8gY3R4LmZpbGxTdHlsZSA9IFwiZ3JleVwiO1xyXG4gICAgLy8gY3R4LmZpbGxSZWN0KDAsIDAsIDcwMCwgNDUwKTtcclxuXHJcbiAgICBjb25zdCBnYW1lID0gbmV3IEdhbWUoY3R4KTtcclxufSlcclxuXHJcbi8vIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsICgpID0+IHtcclxuLy8gICAgIGNvbnN0IGNhbnZhc0VsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjYW52YXNcIik7XHJcbi8vICAgICBjYW52YXNFbC5oZWlnaHQgPSA0NTA7XHJcbi8vICAgICBjYW52YXNFbC53aWR0aCA9IDcwMDtcclxuLy8gICAgIGNvbnN0IGN0eCA9IGNhbnZhc0VsLmdldENvbnRleHQoXCIyZFwiKTtcclxuLy8gICAgIGN0eC5maWxsU3R5bGUgPSBcImdyZXlcIjtcclxuLy8gICAgIGN0eC5maWxsUmVjdCgwLCAwLCA3MDAsIDQ1MCk7XHJcblxyXG4gICAgLy8gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe1xyXG4gICAgLy8gICAgIHZpZGVvOiB7d2lkdGg6IDcwMCwgaGVpZ2h0OiA0NTB9LFxyXG4gICAgLy8gICAgIGF1ZGlvOiBmYWxzZSxcclxuICAgIC8vIH0pLnRoZW4oKHN0cmVhbSkgPT4ge1xyXG4gICAgLy8gICAgIHZpZGVvLnNyY09iamVjdCA9IHN0cmVhbTtcclxuICAgIC8vIH0pO1xyXG4gICAgLy8gY3R4LmRyYXdJbWFnZSh2aWRlbywgMCwgMCwgMTAwMCwgNjAwKTtcclxuICAgIC8vIHZpZGVvID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ2aWRlb1wiKTtcclxuICAgIC8vIHRoaXMuY3R4LmRyYXdJbWFnZSh2aWRlbywgMCwgMCwgMTAwMCwgNjAwKTtcclxuXHJcbiAgICAvLyBjb25zdCBtb2RlbCA9IGZhY2VMYW5kbWFya3NEZXRlY3Rpb24uU3VwcG9ydGVkTW9kZWxzLk1lZGlhUGlwZUZhY2VNZXNoO1xyXG4gICAgLy8gY29uc3QgZGV0ZWN0b3JDb25maWcgPSB7XHJcbiAgICAvLyBydW50aW1lOiAnbWVkaWFwaXBlJywgLy8gb3IgJ3RmanMnXHJcbiAgICAvLyBzb2x1dGlvblBhdGg6ICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0BtZWRpYXBpcGUvZmFjZV9tZXNoJyxcclxuICAgIC8vIH1cclxuICAgIC8vIGNvbnN0IGRldGVjdG9yID0gYXdhaXQgZmFjZUxhbmRtYXJrc0RldGVjdGlvbi5jcmVhdGVEZXRlY3Rvcihtb2RlbCwgZGV0ZWN0b3JDb25maWcpO1xyXG4gICAgLy8gY29uc3QgZmFjZXMgPSBhd2FpdCBkZXRlY3Rvci5lc3RpbWF0ZUZhY2VzKGltYWdlKTtcclxuXHJcbiAgICAvLyBjb25zdCBnYW1lID0gbmV3IEdhbWUoY3R4KTtcclxuLy8gfSlcclxuXHJcbi8vIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsICgpID0+IHtcclxuLy8gICAgIC8vIGxldCB2aWRlbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidmlkZW9cIik7XHJcbi8vICAgICBsZXQgdmlkZW87XHJcbi8vICAgICBsZXQgbW9kZWw7XHJcbi8vICAgICBsZXQgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjYW52YXNcIik7XHJcbi8vICAgICBsZXQgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbi8vICAgICBsZXQgbW91dGhPcGVuID0gZmFsc2U7XHJcbi8vICAgICBsZXQgZXllc0Nsb3NlZCA9IGZhbHNlO1xyXG4vLyAgICAgbGV0IGZhY2U7XHJcbi8vICAgICBsZXQgZmlyc3RGYWNlID0gdHJ1ZTtcclxuXHJcbi8vICAgICBjb25zdCBzZXRVcENhbWVyYSA9ICgpID0+IHtcclxuLy8gICAgICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7XHJcbi8vICAgICAgICAgICAgIHZpZGVvOiB7d2lkdGg6IDEwMDAsIGhlaWdodDogNjAwfSxcclxuLy8gICAgICAgICAgICAgYXVkaW86IGZhbHNlLFxyXG4vLyAgICAgICAgIH0pLnRoZW4oKHN0cmVhbSkgPT4ge1xyXG4vLyAgICAgICAgICAgICB2aWRlby5zcmNPYmplY3QgPSBzdHJlYW07XHJcbi8vICAgICAgICAgfSk7XHJcbi8vICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UodmlkZW8sIDAsIDAsIDEwMDAsIDYwMCk7XHJcbi8vICAgICAgICAgdmlkZW8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInZpZGVvXCIpO1xyXG4vLyAgICAgICAgIGxvYWRGYWNlTW9kZWwoKTtcclxuLy8gICAgIH1cclxuXHJcbi8vICAgICBjb25zdCBsb2FkRmFjZU1vZGVsID0gYXN5bmMgKCkgPT4ge1xyXG4vLyAgICAgICAgIG1vZGVsID0gYXdhaXQgZmFjZUxhbmRtYXJrc0RldGVjdGlvbi5sb2FkKFxyXG4vLyAgICAgICAgICAgICBmYWNlTGFuZG1hcmtzRGV0ZWN0aW9uLlN1cHBvcnRlZFBhY2thZ2VzLm1lZGlhcGlwZUZhY2VtZXNoXHJcbi8vICAgICAgICAgKTtcclxuLy8gICAgIH1cclxuXHJcbi8vICAgICAvLyBjb25zdCBzZXRVcENhbWVyYSA9ICgpID0+IHtcclxuLy8gICAgIC8vICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7XHJcbi8vICAgICAvLyAgICAgICAgIHZpZGVvOiB7d2lkdGg6IDEwMDAsIGhlaWdodDogNjAwfSxcclxuLy8gICAgIC8vICAgICAgICAgYXVkaW86IGZhbHNlLFxyXG4vLyAgICAgLy8gICAgIH0pLnRoZW4oKHN0cmVhbSkgPT4ge1xyXG4vLyAgICAgLy8gICAgICAgICB2aWRlby5zcmNPYmplY3QgPSBzdHJlYW07XHJcbi8vICAgICAvLyAgICAgfSk7XHJcbi8vICAgICAvLyB9O1xyXG5cclxuLy8gICAgIGNvbnN0IGRldGVjdEZhY2VzID0gYXN5bmMgKCkgPT4ge1xyXG4vLyAgICAgICAgIGNvbnN0IGZhY2VQcmVkaWN0aW9uID0gYXdhaXQgbW9kZWwuZXN0aW1hdGVGYWNlcyh2aWRlbywgZmFsc2UpO1xyXG4vLyAgICAgICAgIGlmIChmYWNlUHJlZGljdGlvbi5sZW5ndGggPT09IDApIHtcclxuLy8gICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKFwiRXJyb3I6IG5vIGZhY2UgZGV0ZWN0ZWRcIik7XHJcbi8vICAgICAgICAgfVxyXG4vLyAgICAgICAgIGlmIChmYWNlUHJlZGljdGlvbi5sZW5ndGggPiAxKSB7XHJcbi8vICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLmxvZyhcIkVycm9yOiBUaGlzIGFwcCB3aWxsIG9ubHkgaGFuZGxlIDEgcGVyc29uIGF0IGEgdGltZVwiKTtcclxuLy8gICAgICAgICB9XHJcbi8vICAgICAgICAgY29uc29sZS5sb2coZmFjZVByZWRpY3Rpb24pO1xyXG4vLyAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHZpZGVvLCAwLCAwLCAxMDAwLCA2MDApO1xyXG4vLyAgICAgICAgIGZhY2VQcmVkaWN0aW9uLmZvckVhY2goKHByZWQpID0+IHtcclxuLy8gICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuLy8gICAgICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBcIjRcIjtcclxuLy8gICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IFwiYmx1ZVwiO1xyXG4vLyAgICAgICAgICAgICBpZiAocHJlZC5ib3R0b21SaWdodFswXSAtIHByZWQudG9wTGVmdFswXSAtIDQwIDwgMTI1IHx8IHByZWQuYm90dG9tUmlnaHRbMV0gLSBwcmVkLnRvcExlZnRbMV0gKyAxMTAgPCAyMDApIHtcclxuLy8gICAgICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLmxvZyhcIkVycm9yOiBCcmluZyB5b3VyIGZhY2UgY2xvc2VyIGFuZCBrZWVwIGl0IHN0cmFpZ2h0XCIpO1xyXG4vLyAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICAgIGlmIChwcmVkLmJvdHRvbVJpZ2h0WzBdIC0gcHJlZC50b3BMZWZ0WzBdIC0gNDAgPiAyMjUgfHwgcHJlZC5ib3R0b21SaWdodFsxXSAtIHByZWQudG9wTGVmdFsxXSArIDExMCA+IDMwMCkge1xyXG4vLyAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKFwiRXJyb3I6IEJhY2sgdXAgYSBiaXQgYW5kIGtlZXAgeW91ciBoZWFkIHN0cmFpZ2h0XCIpO1xyXG4vLyAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICAgIGNvbnRleHQucmVjdCAoXHJcbi8vICAgICAgICAgICAgICAgICBwcmVkLnRvcExlZnRbMF0gKyAyMCxcclxuLy8gICAgICAgICAgICAgICAgIHByZWQudG9wTGVmdFsxXSAtIDEwMCxcclxuLy8gICAgICAgICAgICAgICAgIHByZWQuYm90dG9tUmlnaHRbMF0gLSBwcmVkLnRvcExlZnRbMF0gLSA0MCxcclxuLy8gICAgICAgICAgICAgICAgIHByZWQuYm90dG9tUmlnaHRbMV0gLSBwcmVkLnRvcExlZnRbMV0gKyAxMTBcclxuLy8gICAgICAgICAgICAgKTtcclxuLy8gICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcclxuXHJcbi8vICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCJyZWRcIjtcclxuLy8gICAgICAgICAgICAgcHJlZC5sYW5kbWFya3MuZm9yRWFjaCgobGFuZG1hcmspID0+IHtcclxuLy8gICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFJlY3QobGFuZG1hcmtbMF0sIGxhbmRtYXJrWzFdLCA1LCA1KTtcclxuLy8gICAgICAgICAgICAgfSk7XHJcbi8vICAgICAgICAgfSk7XHJcbi8vICAgICB9XHJcblxyXG4vLyAgICAgY29uc3QgZHJhd0ZhY2UgPSBhc3luYyAoKSA9PiB7XHJcbi8vICAgICAgICAgLy8gY29uc3QgZmFjZVByZWRpY3Rpb24gPSBhd2FpdCBtb2RlbC5lc3RpbWF0ZUZhY2VzKHZpZGVvLCBmYWxzZSk7XHJcbi8vICAgICAgICAgZGVidWdnZXJcclxuLy8gICAgICAgICAvLyBpZiAodmlkZW8ubG9hZGVkbWV0YWRhdGEgJiYgbW9kZWwgIT09IHVuZGVmaW5lZCkge1xyXG4vLyAgICAgICAgICAgICBkZXRlY3RGYWNlKCk7XHJcbi8vICAgICAgICAgLy8gfVxyXG4vLyAgICAgICAgIGRlYnVnZ2VyXHJcbi8vICAgICAgICAgaWYgKGZhY2UgIT09IHVuZGVmaW5lZCkge1xyXG4vLyAgICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZSh2aWRlbywgMCwgMCwgMTAwMCwgNjAwKTtcclxuLy8gICAgICAgICAgICAgaWYgKGZpcnN0RmFjZSkge1xyXG4vLyAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZmFjZSk7XHJcbi8vICAgICAgICAgICAgICAgICBmaXJzdEZhY2UgPSBmYWxzZTtcclxuLy8gICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgICBmaWxsKDI1NSk7XHJcbi8vICAgICAgICAgICAgIG5vU3Ryb2tlKCk7XHJcbi8vICAgICAgICAgICAgIGZvciAobGV0IHB0IG9mIGZhY2Uuc2NhbGVkTWVzaCkge1xyXG4vLyAgICAgICAgICAgICAgICAgcHQgPSBzY2FsZVBvaW50KHB0KTtcclxuLy8gICAgICAgICAgICAgICAgIGNpcmNsZShwdC54LCBwdC55LCAzKTtcclxuLy8gICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgICBmaWxsKDAsMTUwLDI1NSwgMTAwKTtcclxuLy8gICAgICAgICAgICAgbm9TdHJva2UoKTtcclxuLy8gICAgICAgICAgICAgYmVnaW5TaGFwZSgpO1xyXG4vLyAgICAgICAgICAgICBmb3IgKHB0IG9mIGZhY2UuYW5ub3RhdGlvbnMuc2lsaG91ZXR0ZSkge1xyXG4vLyAgICAgICAgICAgICAgICAgcHQgPSBzY2FsZVBvaW50KHB0KTtcclxuLy8gICAgICAgICAgICAgICAgIHZlcnRleChwdC54LCBwdC55KTtcclxuLy8gICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgICBlbmRTaGFwZShDTE9TRSk7XHJcbi8vICAgICAgICAgfVxyXG4vLyAgICAgfVxyXG5cclxuLy8gICAgIGNvbnN0IHNjYWxlUG9pbnQgPSAocHQpID0+IHtcclxuLy8gICAgICAgICBsZXQgeCA9IG1hcChwdFswXSwgMCx2aWRlby53aWR0aCwgMCx3aWR0aCk7XHJcbi8vICAgICAgICAgbGV0IHkgPSBtYXAocHRbMV0sIDAsdmlkZW8uaGVpZ2h0LCAwLGhlaWdodCk7XHJcbi8vICAgICAgICAgcmV0dXJuIGNyZWF0ZVZlY3Rvcih4LCB5KTtcclxuLy8gICAgIH1cclxuXHJcbi8vICAgICBjb25zdCBkZXRlY3RGYWNlID0gYXN5bmMgKCkgPT4ge1xyXG4vLyAgICAgICAgIGRlYnVnZ2VyXHJcbi8vICAgICAgICAgY29uc3QgZmFjZVByZWRpY3Rpb25zID0gYXdhaXQgbW9kZWwuZXN0aW1hdGVGYWNlcyh7XHJcbi8vICAgICAgICAgICAgIGlucHV0OiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCd2aWRlbycpXHJcbi8vICAgICAgICAgfSk7XHJcbi8vICAgICAgICAgY29uc29sZS5sb2coZmFjZVByZWRpY3Rpb25zKTtcclxuLy8gICAgICAgICBkZWJ1Z2dlclxyXG4vLyAgICAgICAgIGlmIChmYWNlUHJlZGljdGlvbnMubGVuZ3RoID09PSAwKSB7XHJcbi8vICAgICAgICAgICAgIGZhY2UgPSB1bmRlZmluZWQ7XHJcbi8vICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLmxvZyhcIkVycm9yOiBubyBmYWNlIGRldGVjdGVkXCIpO1xyXG4vLyAgICAgICAgIH0gZWxzZSBpZiAoZmFjZVByZWRpY3Rpb25zLmxlbmd0aCA+IDEpIHtcclxuLy8gICAgICAgICAgICAgZmFjZSA9IHVuZGVmaW5lZDtcclxuLy8gICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKFwiRXJyb3I6IFRoaXMgYXBwIHdpbGwgb25seSBoYW5kbGUgMSBwZXJzb24gYXQgYSB0aW1lXCIpO1xyXG4vLyAgICAgICAgIH0gZWxzZSB7XHJcbi8vICAgICAgICAgICAgIGZhY2UgPSBmYWNlUHJlZGljdGlvbnNbMF07XHJcbi8vICAgICAgICAgfVxyXG4vLyAgICAgICAgIGRlYnVnZ2VyXHJcbi8vICAgICB9XHJcblxyXG4vLyAgICAgc2V0VXBDYW1lcmEoKTtcclxuLy8gICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZWRkYXRhXCIsIGFzeW5jICgpID0+IHtcclxuLy8gICAgICAgICBtb2RlbCA9IGF3YWl0IGZhY2VMYW5kbWFya3NEZXRlY3Rpb24ubG9hZChcclxuLy8gICAgICAgICAgICAgZmFjZUxhbmRtYXJrc0RldGVjdGlvbi5TdXBwb3J0ZWRQYWNrYWdlcy5tZWRpYXBpcGVGYWNlbWVzaFxyXG4vLyAgICAgICAgICk7XHJcbi8vICAgICAgICAgLy8gZGV0ZWN0RmFjZSgpO1xyXG4vLyAgICAgICAgIGRyYXdGYWNlKCk7XHJcbi8vICAgICAgICAgLy8gc2V0SW50ZXJ2YWwoZGV0ZWN0RmFjZSwgNTApO1xyXG4vLyAgICAgfSlcclxuLy8gfSkiXSwibmFtZXMiOlsiR2FtZSIsImRvY3VtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImNhbnZhc0VsIiwiZ2V0RWxlbWVudEJ5SWQiLCJoZWlnaHQiLCJ3aWR0aCIsImN0eCIsImdldENvbnRleHQiLCJnYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ "./src/scripts/game.js":
/*!*****************************!*\
  !*** ./src/scripts/game.js ***!
  \*****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\nclass Game {\n  constructor(ctx) {\n    this.video = document.getElementById(\"video\");\n    this.ctx = ctx;\n    this.mode = \"gameon\";\n    this.model; // Checks to see if game is playing to set up camera and load face models\n\n    if (this.mode === \"gameon\") {\n      this.setupCamera();\n      this.loadFaceModel(); // Sets interval to loop the draw function (which loses context)\n\n      setInterval(this.draw.bind(this), 20);\n    }\n  }\n\n  setupCamera() {\n    // Using the mediaDevices API to grab the video\n    navigator.mediaDevices.getUserMedia({\n      video: {\n        width: 700,\n        height: 450\n      },\n      audio: false\n    }).then(stream => {\n      // Which returns us a promise which we then take the stream and set that to the video srcObject\n      this.video.srcObject = stream;\n    });\n  }\n\n  loadFaceModel() {\n    // Waiting for the video to have a stream from the setupCamera function\n    this.video.addEventListener(\"loadeddata\", async () => {\n      // Then loads the face detection API\n      this.model = await faceLandmarksDetection.load(faceLandmarksDetection.SupportedPackages.mediapipeFacemesh);\n    });\n  }\n\n  async detectFace(ctx) {\n    // Here we grab the model we waited from the API for and grab its preditions\n    // from estimatFaces function passing in the video element in order to detect those faces\n    const prediction = await this.model.estimateFaces({\n      input: document.querySelector('video')\n    });\n    this.ctx.drawImage(this.video, 0, 0, 700, 450);\n    console.log(prediction);\n  } // Load face models predictions before drawing which happens in the detectFace function\n\n\n  draw() {\n    // This is so that we don't error out before out video loads up\n    if (this.model !== undefined) {\n      this.detectFace(this.ctx);\n    }\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Game);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2NyaXB0cy9nYW1lLmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNQSxJQUFOLENBQVc7RUFFUEMsV0FBVyxDQUFDQyxHQUFELEVBQU07SUFDYixLQUFLQyxLQUFMLEdBQWFDLFFBQVEsQ0FBQ0MsY0FBVCxDQUF3QixPQUF4QixDQUFiO0lBQ0EsS0FBS0gsR0FBTCxHQUFXQSxHQUFYO0lBQ0EsS0FBS0ksSUFBTCxHQUFZLFFBQVo7SUFDQSxLQUFLQyxLQUFMLENBSmEsQ0FNYjs7SUFDQSxJQUFJLEtBQUtELElBQUwsS0FBYyxRQUFsQixFQUEyQjtNQUN2QixLQUFLRSxXQUFMO01BQ0EsS0FBS0MsYUFBTCxHQUZ1QixDQUd2Qjs7TUFDQUMsV0FBVyxDQUFDLEtBQUtDLElBQUwsQ0FBVUMsSUFBVixDQUFlLElBQWYsQ0FBRCxFQUF1QixFQUF2QixDQUFYO0lBQ0g7RUFDSjs7RUFFREosV0FBVyxHQUFHO0lBQ1Y7SUFDQUssU0FBUyxDQUFDQyxZQUFWLENBQXVCQyxZQUF2QixDQUFvQztNQUNoQ1osS0FBSyxFQUFFO1FBQUNhLEtBQUssRUFBRSxHQUFSO1FBQWFDLE1BQU0sRUFBRTtNQUFyQixDQUR5QjtNQUVoQ0MsS0FBSyxFQUFFO0lBRnlCLENBQXBDLEVBR0dDLElBSEgsQ0FHU0MsTUFBTSxJQUFJO01BQ2Y7TUFDQSxLQUFLakIsS0FBTCxDQUFXa0IsU0FBWCxHQUF1QkQsTUFBdkI7SUFDSCxDQU5EO0VBT0g7O0VBRURYLGFBQWEsR0FBRztJQUNaO0lBQ0EsS0FBS04sS0FBTCxDQUFXbUIsZ0JBQVgsQ0FBNEIsWUFBNUIsRUFBMEMsWUFBWTtNQUNsRDtNQUNBLEtBQUtmLEtBQUwsR0FBYSxNQUFNZ0Isc0JBQXNCLENBQUNDLElBQXZCLENBQ2ZELHNCQUFzQixDQUFDRSxpQkFBdkIsQ0FBeUNDLGlCQUQxQixDQUFuQjtJQUdILENBTEQ7RUFNSDs7RUFFZSxNQUFWQyxVQUFVLENBQUN6QixHQUFELEVBQU07SUFDbEI7SUFDQTtJQUNBLE1BQU0wQixVQUFVLEdBQUcsTUFBTSxLQUFLckIsS0FBTCxDQUFXc0IsYUFBWCxDQUF5QjtNQUM5Q0MsS0FBSyxFQUFFMUIsUUFBUSxDQUFDMkIsYUFBVCxDQUF1QixPQUF2QjtJQUR1QyxDQUF6QixDQUF6QjtJQUdBLEtBQUs3QixHQUFMLENBQVM4QixTQUFULENBQW1CLEtBQUs3QixLQUF4QixFQUErQixDQUEvQixFQUFrQyxDQUFsQyxFQUFxQyxHQUFyQyxFQUEwQyxHQUExQztJQUVBOEIsT0FBTyxDQUFDQyxHQUFSLENBQVlOLFVBQVo7RUFDSCxDQS9DTSxDQWlEUDs7O0VBQ0FqQixJQUFJLEdBQUc7SUFDSDtJQUNBLElBQUksS0FBS0osS0FBTCxLQUFlNEIsU0FBbkIsRUFBOEI7TUFDMUIsS0FBS1IsVUFBTCxDQUFnQixLQUFLekIsR0FBckI7SUFDSDtFQUNKOztBQXZETTs7QUEyRFgsK0RBQWVGLElBQWYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9GQUNFTUFOLVJldmFtcGVkLy4vc3JjL3NjcmlwdHMvZ2FtZS5qcz9jZGMwIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEdhbWUge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGN0eCkge1xyXG4gICAgICAgIHRoaXMudmlkZW8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInZpZGVvXCIpO1xyXG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xyXG4gICAgICAgIHRoaXMubW9kZSA9IFwiZ2FtZW9uXCI7XHJcbiAgICAgICAgdGhpcy5tb2RlbDtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2tzIHRvIHNlZSBpZiBnYW1lIGlzIHBsYXlpbmcgdG8gc2V0IHVwIGNhbWVyYSBhbmQgbG9hZCBmYWNlIG1vZGVsc1xyXG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09IFwiZ2FtZW9uXCIpe1xyXG4gICAgICAgICAgICB0aGlzLnNldHVwQ2FtZXJhKCk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZEZhY2VNb2RlbCgpO1xyXG4gICAgICAgICAgICAvLyBTZXRzIGludGVydmFsIHRvIGxvb3AgdGhlIGRyYXcgZnVuY3Rpb24gKHdoaWNoIGxvc2VzIGNvbnRleHQpXHJcbiAgICAgICAgICAgIHNldEludGVydmFsKHRoaXMuZHJhdy5iaW5kKHRoaXMpLCAyMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNldHVwQ2FtZXJhKCkge1xyXG4gICAgICAgIC8vIFVzaW5nIHRoZSBtZWRpYURldmljZXMgQVBJIHRvIGdyYWIgdGhlIHZpZGVvXHJcbiAgICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe1xyXG4gICAgICAgICAgICB2aWRlbzoge3dpZHRoOiA3MDAsIGhlaWdodDogNDUwfSxcclxuICAgICAgICAgICAgYXVkaW86IGZhbHNlLFxyXG4gICAgICAgIH0pLnRoZW4oIHN0cmVhbSA9PiB7XHJcbiAgICAgICAgICAgIC8vIFdoaWNoIHJldHVybnMgdXMgYSBwcm9taXNlIHdoaWNoIHdlIHRoZW4gdGFrZSB0aGUgc3RyZWFtIGFuZCBzZXQgdGhhdCB0byB0aGUgdmlkZW8gc3JjT2JqZWN0XHJcbiAgICAgICAgICAgIHRoaXMudmlkZW8uc3JjT2JqZWN0ID0gc3RyZWFtO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGxvYWRGYWNlTW9kZWwoKSB7XHJcbiAgICAgICAgLy8gV2FpdGluZyBmb3IgdGhlIHZpZGVvIHRvIGhhdmUgYSBzdHJlYW0gZnJvbSB0aGUgc2V0dXBDYW1lcmEgZnVuY3Rpb25cclxuICAgICAgICB0aGlzLnZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZWRkYXRhXCIsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgLy8gVGhlbiBsb2FkcyB0aGUgZmFjZSBkZXRlY3Rpb24gQVBJXHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSBhd2FpdCBmYWNlTGFuZG1hcmtzRGV0ZWN0aW9uLmxvYWQoXHJcbiAgICAgICAgICAgICAgICBmYWNlTGFuZG1hcmtzRGV0ZWN0aW9uLlN1cHBvcnRlZFBhY2thZ2VzLm1lZGlhcGlwZUZhY2VtZXNoXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgZGV0ZWN0RmFjZShjdHgpIHtcclxuICAgICAgICAvLyBIZXJlIHdlIGdyYWIgdGhlIG1vZGVsIHdlIHdhaXRlZCBmcm9tIHRoZSBBUEkgZm9yIGFuZCBncmFiIGl0cyBwcmVkaXRpb25zXHJcbiAgICAgICAgLy8gZnJvbSBlc3RpbWF0RmFjZXMgZnVuY3Rpb24gcGFzc2luZyBpbiB0aGUgdmlkZW8gZWxlbWVudCBpbiBvcmRlciB0byBkZXRlY3QgdGhvc2UgZmFjZXNcclxuICAgICAgICBjb25zdCBwcmVkaWN0aW9uID0gYXdhaXQgdGhpcy5tb2RlbC5lc3RpbWF0ZUZhY2VzKHtcclxuICAgICAgICAgICAgaW5wdXQ6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3ZpZGVvJylcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UodGhpcy52aWRlbywgMCwgMCwgNzAwLCA0NTApO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhwcmVkaWN0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBMb2FkIGZhY2UgbW9kZWxzIHByZWRpY3Rpb25zIGJlZm9yZSBkcmF3aW5nIHdoaWNoIGhhcHBlbnMgaW4gdGhlIGRldGVjdEZhY2UgZnVuY3Rpb25cclxuICAgIGRyYXcoKSB7XHJcbiAgICAgICAgLy8gVGhpcyBpcyBzbyB0aGF0IHdlIGRvbid0IGVycm9yIG91dCBiZWZvcmUgb3V0IHZpZGVvIGxvYWRzIHVwXHJcbiAgICAgICAgaWYgKHRoaXMubW9kZWwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmRldGVjdEZhY2UodGhpcy5jdHgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEdhbWU7Il0sIm5hbWVzIjpbIkdhbWUiLCJjb25zdHJ1Y3RvciIsImN0eCIsInZpZGVvIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsIm1vZGUiLCJtb2RlbCIsInNldHVwQ2FtZXJhIiwibG9hZEZhY2VNb2RlbCIsInNldEludGVydmFsIiwiZHJhdyIsImJpbmQiLCJuYXZpZ2F0b3IiLCJtZWRpYURldmljZXMiLCJnZXRVc2VyTWVkaWEiLCJ3aWR0aCIsImhlaWdodCIsImF1ZGlvIiwidGhlbiIsInN0cmVhbSIsInNyY09iamVjdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJmYWNlTGFuZG1hcmtzRGV0ZWN0aW9uIiwibG9hZCIsIlN1cHBvcnRlZFBhY2thZ2VzIiwibWVkaWFwaXBlRmFjZW1lc2giLCJkZXRlY3RGYWNlIiwicHJlZGljdGlvbiIsImVzdGltYXRlRmFjZXMiLCJpbnB1dCIsInF1ZXJ5U2VsZWN0b3IiLCJkcmF3SW1hZ2UiLCJjb25zb2xlIiwibG9nIiwidW5kZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/scripts/game.js\n");

/***/ }),

/***/ "./src/index.scss":
/*!************************!*\
  !*** ./src/index.scss ***!
  \************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguc2Nzcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9GQUNFTUFOLVJldmFtcGVkLy4vc3JjL2luZGV4LnNjc3M/OTc0NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.scss\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	__webpack_require__("./src/index.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.scss");
/******/ 	
/******/ })()
;